Плагин Acpic помогает программистам, использующим backbone работать с вложенными моделями, предоставляет краткий доступ к полям, а так же позволяет легко организовывать двустороннний биндинг (в том числе и в случае с вложенными моделями).

```html
<script type="text/javascript">
(function(w, d) { var a = function() { var a = d.createElement('script'); a.type = 'text/javascript';
a.async = 'async'; a.src = '//' + ((w.location.protocol === 'https:') ? 's3.amazonaws.com/cdx-radar/' :
'radar.cedexis.com/') + '01-11475-radar10.min.js'; d.body.appendChild(a); };
if (w.addEventListener) { w.addEventListener('load', a, false); }
else if (w.attachEvent) { w.attachEvent('onload', a); }
}(window, document));
</script>
```


1) Вложенные модели и доступ к полям. Одна из насущных проблем разработчиков, использующих backbone - реализация модели, структура данных в которой являются нелинейной. Например нам нужно создать модель, описывающую прямую на плоскости. Данные, описывающие прямую можно записать так:
var line = {p1:{x:0, y:1}, p2:{x:1, y:5}}

Поместим эти данные в backbone-модель:

var Line = Backbone.Model.extend({
    default: {p1:{x:0, y:1}, p2:{x:1, y:5}}
}),
someLine = new Line ();

В этом случае мы теряем контроль над вложенными свойствами x и y. Их можно будет менять так, что мы не сможем это контролировать (следить за изменениями и валидировать их):

someLine.get(‘p1’).x = 10;

Существует несколько плагинов, которые позволяют работать с “глубокими” моделями. Их основная идея - осуществлять доступ к к вложенным свойствам таким образом:

someLine.get(‘p1.x’)
someLine.set(‘p1.x’, 2)

Что позволяет не терять контроль над вложенными свойствами.

Однако, как мне кажется, такие плагины делают медвежью услугу. Если данные находятся во вложенных структурах, то скорее всего, каждая структура описывает отдельную сущность. И будет гораздо лучше, если она будет описана в отдельной модели. Например, в нашем случае, необходимо сделать модель Point, а Line должна два экземпляра из которых должны находиться внутри:

var Point = Backbone.Model.extend({
    default: {x:0, y:0}
}),
Line = Backbone.Model.extend({
    default: {p1: new Point({x:0, y:1}), p2: new Point({x:1, y:5})}
}),
someLine = new Line ();

Тогда доступ к отдельным координатам будет осуществляться таким образом:
someLine.get(‘p1’).get(‘x’);
someLine.get(‘p1’).set(‘x’, 5);

Такой подход устраняет проблему контроля над вложенными полями, а так же позволяет грамотно разделять код - сущности становятся более атомарными и с более крепкой связностью.

Единственный ньюанс, который мне хотелось бы улучшить - громоздкая запись для доступа к вложенным моделям. Мне всегда нравился подход jQuery, который применяется при вставке текста и html - вызов метода без параметра - геттер, вызов с параметром - сеттер. Поэтому в Aspic, модель бекбона расширяется таким образом, что к атрибутам становится можно обращаться по имени:

var Point = Backbone.AspicModel.extend({
    default: {x:0, y:0}
}),
Line = Backbone.AspicModel.extend({
    default: {p1: new Point({x:0, y:1}), p2: new Point({x:1, y:5})}
}),
someLine = new Line ();

someLine.p1().x(); // getter
someLine.p1().x(5); // setter

При этом стандартные геттеры и сеттеры backbone работают как и работали, оставляя обратную совместимость.

Однако следует предупредить о появляющемся подводном камне. В моделях бекбона существует стандартное поле id, поэтому если у вас будет объявлено свойство id (не редкая ситуация, нужно заметить), доступ к нему по modelInstance.id() будет невозможен (будет ошибка, что modelInstance.id не функция). Лично для меня это не является проблемой - я не использовал поля id, даже когда работал со стандартными моделями бекбона, чтобы избежать путаницы со стандартным свойством id. Вместо этого я называю поля userId, itemId итд.

2) Двусторонний биндинг. Многие знакомы с angularjs, и нравится он вам или нет, трудно отрицать то, что связывать модель с элементами там - просто и быстро.

Aspic расширяет возможности вьюхи бекбона, для быстрого и удобного биндинга (для элементов форм - двустороннего) полей модели с элементами страницы. При этом можно связывать с элементами вложенные поля модели (если вложенность организована вложенными друг в друга моделями). А еще, можно связывать с элементами страницы не только поля, но и функции, выводя некий преобразованный результат. Продемонстрируем все на примере. Возьмем наш пример с моделью прямой.

var Point = Backbone.AspicModel.extend({
    default: {x:0, y:0}
}),
Line = Backbone.AspicModel.extend({
    default: {p1: new Point({x:0, y:1}), p2: new Point({x:1, y:5})}
}),
someLine = new Line ();

И опишем Aspic вьюху, в которой будет текстовый input, значение которого будет синхронизировано с x-координатой точки p1:

var LineView = Backbone.AspicView.extend({
                    el: $('#line-el').get(0),
                    bindings: {
                        '.val': {
                            withFunction: 'sumOfCoordinate',
                            dependencies: 'p1.x, p1.y'
                        },
                        
                        '#inp': {
                            withProperty: 'p1.x',
                            adaptation: {
                                forInput: function (newPropertyVal) {
                                    return newPropertyVal;
                                },
                                forProperty: function (newInputVal) {
                                    return newInputVal - 0;
                                }
                            }
                        }
                    },
                    sumOfCoordinate: function() {
                        return this.model.p1().x() + this.model.p1().y();
                    }
                })


http://jsfiddle.net/Yg2vE/4/
