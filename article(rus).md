Плагин Acpic помогает программистам, использующим backbone, работать с вложенными моделями, предоставляет простой доступ к полям, а так же позволяет легко организовывать двустороннний биндинг (в том числе и для вложенных моделей).


1. **Вложенные модели и доступ к полям.** Одна из насущных проблем разработчиков, использующих backbone - реализация модели, структура данных в которой являются нелинейной. Например нам нужно создать модель, описывающую прямую на плоскости. Данные, описывающие прямую можно записать так:
```html
<script type="text/javascript">
    var line = {
        p1:{x:0, y:1}, 
        p2:{x:1, y:5}
    };
</script>
```

Поместим эти данные в backbone-модель:
```html
<script type="text/javascript">
    var Line = Backbone.Model.extend({
        default: {
            p1:{x:0, y:1}, 
            p2:{x:1, y:5}
        }
    }),
    someLine = new Line ();
</script>
```

В этом случае мы теряем контроль над вложенными свойствами x и y. Их можно будет менять так, что мы не сможем это контролировать (следить за изменениями и валидировать их):

`someLine.get('p1').x = 10;`

Существует несколько плагинов, которые позволяют работать с “глубокими” моделями. Их основная идея - осуществлять доступ к к вложенным свойствам таким образом:

`someLine.get('p1.x') // getter`
`someLine.set('p1.x', 2) // setter`

Что позволяет не терять контроль над вложенными свойствами.

Однако, как мне кажется, такие плагины делают медвежью услугу. Если данные находятся во вложенных структурах, то скорее всего, каждая структура описывает отдельную сущность. И будет гораздо лучше, если она будет описана в отдельной модели (single responsibility, все дела). Например, в нашем случае, необходимо сделать модель Point, отвечающая за одну точку на плоскости, а Line будет содержать два экземпляра Point:

```html
<script type="text/javascript">
    var Point = Backbone.Model.extend({
        default: {x:0, y:0}
    }),
    
    Line = Backbone.Model.extend({
        default: {
            p1: new Point({x:0, y:1}), 
            p2: new Point({x:1, y:5})
        }
    }),
    
    someLine = new Line ();
</script>
```

Тогда доступ к отдельным координатам будет осуществляться таким образом:

`someLine.get('p1').get('x');`
`someLine.get('p1').set('x', 5);`

Такой подход устраняет проблему контроля над вложенными полями, а так же позволяет грамотно разделять код - сущности становятся более атомарными и с более крепкой связностью.

Единственный ньюанс, который мне хотелось бы улучшить - громоздкая запись для доступа к вложенным моделям. Мне всегда нравился подход jQuery, который применяется при вставке текста и html - вызов метода без параметра - getter, вызов с параметром - setter. Для этого, в Aspic, модель бекбона расширяется таким образом, чтобы к атрибутам можно было обращаться по имени:

```html
<script>
    var Point = Backbone.AspicModel.extend({
        default: {x:0, y:0}
    }),
    
    Line = Backbone.AspicModel.extend({
        default: {
            p1: new Point({x:0, y:1}), 
            p2: new Point({x:1, y:5})}
    }),
    
    someLine = new Line ();
    
    someLine.p1().x(); // getter
    someLine.p1().x(5); // setter
</script>
```

При этом стандартные getter'ы и setter'ы backbone работают как и работали, оставляя обратную совместимость.

Однако, следует предупредить о появляющемся подводном камне. В моделях бекбона существует стандартное поле id, поэтому если у вас будет объявлено свойство id (не редкая ситуация, нужно заметить), доступ к нему по `modelInstance.id()` будет невозможен (будет ошибка, что modelInstance.id не функция). Лично для меня это не является проблемой - я не использовал поля id, даже когда работал со стандартными моделями бекбона, чтобы избежать путаницы со стандартным свойством id. Вместо этого я называю поля userId, itemId итд.

2) Двусторонний биндинг. Многие знакомы с angularjs, и нравится он вам или нет, трудно отрицать то, что связывать модель с элементами там - просто и быстро.

Aspic расширяет возможности вьюхи бекбона, для быстрого и удобного биндинга (для элементов форм - двустороннего) полей модели с элементами страницы. При этом можно связывать с элементами вложенные поля модели (если вложенность организована вложенными друг в друга моделями). А еще, можно связывать с элементами страницы не только поля, но и функции, выводя некий преобразованный результат. Продемонстрируем все на примере. Возьмем наш пример с моделью прямой.

```html
<script>
var Point = Backbone.AspicModel.extend({
        defaults: {
            x: 5,
            y: 5
        }
    }),
    
    Line = Backbone.AspicModel.extend({
        defaults: {
            p1: new Point({ x: 1, y: 2 }),
            p2: new Point()
        }
    }),
    
    l = new Line();
</script>
```

И опишем Aspic View, в которой будет текстовый input, значение которого будет синхронизировано с x-координатой точки p1:

```html
<script>
var LineView = Backbone.AspicView.extend({
        el: $('#line-el').get(0),
        
        bindings: {
            '#inp': {
                withProperty: 'p1.x',
                adaptation: {
                    forInput: function (newPropertyVal) {
                        return newPropertyVal;
                    },
                    forProperty: function (newInputVal) {
                        return newInputVal - 0;
                    }
                }
            },
            
            '.val': {
                withFunction: 'lenOfLine',
                dependencies: 'p1.x, p1.y, p2.x, p2.y'
            }
        },
        
        lenOfLine: function() {
           var deltaX = Math.pow(this.model.p1().x() - this.model.p2().x(), 2),
               deltaY = Math.pow(this.model.p1().y() - this.model.p2().y(), 2);
           return Math.sqrt( deltaX + deltaY );
        }
    }),
    
    lw = new LineView({model: l});
</script>
```


Результат можно посмотреть здесь http://jsfiddle.net/Yg2vE/7/ .

Как видно, биндинг прописывается в свойстве `bindings` при создании вьюхи. Он описывается объектом, ключи которого являются селекторами элементов страницы, которые должны быть привязаны к модели. Значением объекта `bindings` является объект, в котором описано с каким полем или функцией нужно связать элемент страницы.

В начале мы привязываем к текстовому полю (с id = "inp") координату x, первой точки прямой. Поскольку значение текстового поля всегда интерпретируются как текст, нам необходимо преобразовывать введенное значение в число. Для этого, при биндинге можно указывать свойство `adaptation`, в котором можно указывать преобразования и для элемента и для модели.

Следующим пунктом мы привязываем в элемент с классом val значение функции, которая считает длинну прямой. Однако встает вопрос, в какой момент ее нужно будет пересчитывать. Для этого в свойстве `dependencies` указываются поля модели, изменение которых будет приводить к пересчету значения.
